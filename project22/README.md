# 项目内容

**Project22: research report on MPT**

# MPT

## 概述

**MPT**指的是**Merkle Patricia Tree**（又称为**Merkle Patricia Trie**）是一种经过改良的、融合了**默克尔树**和**前缀树**两种树结构优点的数据结构，
是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。

![image](https://github.com/korangar-group42num1/group42/assets/129478905/3a5970d5-fc13-4926-adc5-44268d2f12aa)

## 前缀树

前缀树（又称字典树），用于保存关联数组，其键（key）的内容通常为字符串。

前缀树节点在树中的位置是由其键的内容所决定的，即前缀树的key值被编码在根节点到该节点的路径中。

如下图所示，图中共有6个叶子节点，其key的值分别为（1）to（2）tea（3）ted（4）ten（5）A（6）inn

![image](https://github.com/korangar-group42num1/group42/assets/129478905/5148fe75-95cf-43b1-af3f-2989f84d287f)

### 优点

相比于哈希表，使用前缀树来进行查询拥有共同前缀key的数据时十分高效。
例如在字典中查找前缀为pre的单词，对于哈希表来说，需要遍历整个表，时间效率为O(n)；
然而对于前缀树来说，只需要在树中找到前缀为pre的节点，且遍历以这个节点为根节点的子树即可。
但是对于最差的情况（前缀为空串），时间效率为O(n)，仍然需要遍历整棵树，此时效率与哈希表相同。
相比于哈希表，在前缀树不会存在哈希冲突的问题。


### 缺点

#### 直接查找效率低下

前缀树的查找效率是O(m)，m为所查找节点的key长度，而哈希表的查找效率为O(1)。
且一次查找会有m次IO开销，相比于直接查找，无论是速率、还是对磁盘的压力都比较大。

#### 可能造成空间浪费

当存在一个节点，其key值内容很长（如一串很长的字符串），当树中没有与他相同前缀的分支时，为了存储该节点，
需要创建许多非叶子节点来构建根节点到该节点间的路径，造成了存储空间的浪费。

## Merkle Tree（默克尔树）

[点击](project5/README.md) 可直接查看 **porject5** 的实验报告中对Merkle Tree的介绍，此处不再赘述。

### 优点

#### 快速重哈希

默克尔树的特点之一就是当树节点内容发生变化时，能够在前一次哈希计算的基础上，仅仅将被修改的树节点进行哈希重计算，
便能得到一个新的根哈希用来代表整棵树的状态。

#### 轻节点扩展

采用默克尔树，可以在公链环境下扩展一种“轻节点”。轻节点的特点是对于每个区块，仅仅需要存储约80个字节大小的区块头数据，
而不存储交易列表，回执列表等数据。然而通过轻节点，可以实现在非信任的公链环境中验证某一笔交易是否被收录在区块链账本的功能。
这使得像比特币，以太坊这样的区块链能够运行在个人PC，智能手机等拥有小存储容量的终端上。

### 缺点

#### 存储控价开销大

## MPT树的结构

如上文所述，尽管前缀树可以起到维护key-value数据的目的，但是其具有十分明显的局限性。无论是查询操作，还是对数据的增删改，
不仅效率低下，且存储空间浪费严重。故，在以太坊中，为MPT树新增了几种不同类型的树节点，以尽量压缩整体的树高、降低操作的复杂度。

### 树节点分类

**1.分支节点**

**2.叶子节点**

**3.扩展节点**

**4.空节点**



#### 分支节点

分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点， 其定义如下所示：

```c++
type fullNode struct {
        Children [17]node // Actual trie node data to encode/decode (needs custom encoder)
        flags    nodeFlag
}
 
// nodeFlag contains caching-related metadata about a node.
type nodeFlag struct {
    hash  hashNode // cached hash of the node (may be nil)
    gen   uint16   // cache generation counter
    dirty bool     // whether the node has changes that must be written to the database
}
 
```

与前缀树相同，MPT同样是把key-value数据项的key编码在树的路径中，但是key的每一个字节值的范围太大（[0-127]），
因此在以太坊中，在进行树操作之前，首先会进行一个key编码的转换（下节会详述），将一个字节的高低四位内容分拆成两个字节存储。
通过编码转换，key'的每一位的值范围都在[0, 15]内。因此，一个分支节点的孩子至多只有16个。以太坊通过这种方式，减小了每个分支节点的容量，
但是在一定程度上增加了树高。

分支节点的孩子列表中，最后一个元素是用来存储自身的内容。

此外，每个分支节点会有一个附带的字段nodeFlag，记录了一些辅助数据：

**节点哈希**：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；

**脏标志**：当一个节点被修改时，该标志位被置为1；

**诞生标志**：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多；

#### 叶子结点&&扩展节点

叶子节点与扩展节点的定义相似，如下所示：

```c++
type shortNode struct {
        Key   []byte
        Val   node
        flags nodeFlag
}
 
```

其中关键的字段为：

**Key**：用来存储属于该节点范围的key；

**Val**：用来存储该节点的内容；

##### Key

其中Key是MPT树实现树高压缩的关键

为了克服存储空间浪费的情况，MPT树对此进行了优化：当MPT试图插入一个节点，
插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把剩余的Key存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。
例如图中我们将红线所圈的节点称为node1, 将蓝线所圈的节点称为node2。node1与node2共享路径前缀t，但是node1在插入时，
树中没有与oast有共同前缀的路径，因此node1的key为oast，实现了编码路径的压缩。

![image](https://github.com/korangar-group42num1/group42/assets/129478905/7d34fbe8-207a-45a2-ad73-0936231ef860)

这种做法的**优势**

**提高节点的查找效率，避免过多的磁盘访问；**

**减少存储空间浪费，避免存储无用的节点；**

key值以下具有三种编码方式

**1.Raw编码（原生的字符）：** 原生的key值，不做任何改变。这种编码方式的key，是MPT对外提供接口的默认编码方式。

```
例如一条key为“cat”，value为“dog”的数据项，其Raw编码就是['c', 'a', 't']，换成ASCII表示方式就是[63, 61, 74]
```

**2.Hex编码（扩展的16进制编码）；**

从Raw编码向Hex编码的转换规则是：
```
将Raw编码的每个字符，根据高4位低4位拆成两个字节；

若该Key对应的节点存储的是真实的数据项内容（即该节点是叶子节点），则在末位添加一个ASCII值为16的字符作为终止标志符；

若该key对应的节点存储的是另外一个节点的哈希索引（即该节点是扩展节点），则不加任何字符；
```

```
key为“cat”, value为“dog”的数据项，其Hex编码为[3, 15, 3, 13, 4, 10, 16]
```

**3.Hex-Prefix编码（16进制前缀编码）；**

那么当节点加载到内存是，同样需要通过一种额外的机制来区分节点的类型。于是以太坊就提出了一种HP编码对存储在数据库中
的叶子／扩展节点的key进行编码区分。在将这两类节点持久化到数据库之前，首先会对该节点的key做编码方式的转换，即从Hex编码转换成HP编码。

HP编码的规则如下：
```
若原key的末尾字节的值为16（即该节点是叶子节点），去掉该字节；

在key之前增加一个半字节，其中最低位用来编码原本key长度的奇偶信息，key长度为奇数，则该位为1；低2位中编码一个特殊的终止标记符，若该节点为叶子节点，则该位为1；

若原本key的长度为奇数，则在key之前再增加一个值为0x0的半字节；

将原本key的内容作压缩，即将两个字符以高4位低4位进行划分，存储在一个字节中（Hex扩展的逆过程）；
```

```
若Hex编码为[3, 15, 3, 13, 4, 10, 16]，则HP编码的值为[32, 63, 61, 74]
```

以上三种编码方式的**转换关系**为：
```
Raw编码：原生的key编码，是MPT对外提供接口中使用的编码方式，当数据项被插入到树中时，Raw编码被转换成Hex编码；

Hex编码：16进制扩展编码，用于对内存中树节点key进行编码，当树节点被持久化到数据库时，Hex编码被转换成HP编码；

HP编码：16进制前缀编码，用于对数据库中树节点key进行编码，当树节点被加载到内存时，HP编码被转换成Hex编码；
```
![image](https://github.com/korangar-group42num1/group42/assets/129478905/f511f89a-ac7d-49b1-9deb-183d76d34680)

##### Val

Val字段用来存储叶子／扩展节点的内容，对于叶子节点来说，该字段存储的是一个数据项的内容；
而对于扩展节点来说，该字段可以是以下两种内容：

1.Val字段存储的是其孩子节点在数据库中存储的索引值（其实该索引值也是孩子节点的哈希值）；

2.Val字段存储的是其孩子节点的引用；

## MPT树木的基本操作


![image](https://github.com/korangar-group42num1/group42/assets/129478905/82865e3a-3200-408c-b4e5-572779182820)


### Get

一次Get操作的过程为：

将需要查找Key的Raw编码转换成Hex编码，得到的内容称之为搜索路径；

1.从根节点开始搜寻与搜索路径内容一致的路径；

2.

(1)若当前节点为叶子节点，存储的内容是数据项的内容，且搜索路径的内容与叶子节点的key一致，则表示找到该节点；反之则表示该节点在树中不存在。

(2)若当前节点为扩展节点，且存储的内容是哈希索引，则利用哈希索引从数据库中加载该节点，再将搜索路径作为参数，对新解析出来的节点递归地调用查找函数。

(3)若当前节点为扩展节点，存储的内容是另外一个节点的引用，且当前节点的key是搜索路径的前缀，则将搜索路径减去当前节点的key，将剩余的搜索路径作为参数，
对其子节点递归地调用查找函数；若当前节点的key不是搜索路径的前缀，表示该节点在树中不存在。

(4)若当前节点为分支节点，若搜索路径为空，则返回分支节点的存储内容；反之利用搜索路径的第一个字节选择分支节点的孩子节点，
将剩余的搜索路径作为参数递归地调用查找函数。


![image](https://github.com/korangar-group42num1/group42/assets/129478905/3b876a41-737f-4859-a7d9-60b0f70f3762)


### Insert

插入操作也是基于查找过程完成的，一个插入过程为：

1.首先找到与新插入节点拥有最长相同路径前缀的节点，记为Node；

2.若该Node为分支节点：

(1)剩余的搜索路径不为空，则将新节点作为一个叶子节点插入到对应的孩子列表中；

(2)剩余的搜索路径为空（完全匹配），则将新节点的内容存储在分支节点的第17个孩子节点项中（Value）；

3.若该节点为叶子／扩展节点：

(1)剩余的搜索路径与当前节点的key一致，则把当前节点Val更新即可；

(2)剩余的搜索路径与当前节点的key不完全一致，则将叶子／扩展节点的孩子节点替换成分支节点，
将新节点与当前节点key的共同前缀作为当前节点的key，将新节点与当前节点的孩子节点作为两个孩子插入到分支节点的孩子列表中，
同时当前节点转换成了一个扩展节点（若新节点与当前节点没有共同前缀，则直接用生成的分支节点替换当前节点）；

4.若插入成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；


![image](https://github.com/korangar-group42num1/group42/assets/129478905/ed0a3b31-0e1a-496d-acb4-cc7f8d460718)


### Delete

删除操作与插入操作类似，都需要借助查找过程完成，一次删除过程为：

1.根据4.1中描述的查找步骤，找到与需要插入的节点拥有最长相同路径前缀的节点，记为Node；

2.若Node为叶子／扩展节点：

(1)若剩余的搜索路径与node的Key完全一致，则将整个node删除；

(2)若剩余的搜索路径与node的key不匹配，则表示需要删除的节点不存于树中，删除失败；

(3)若node的key是剩余搜索路径的前缀，则对该节点的Val做递归的删除调用；

3.若Node为分支节点：

(1)删除孩子列表中相应下标标志的节点；

(2)删除结束，若Node的孩子个数只剩下一个，那么将分支节点替换成一个叶子／扩展节点；

4.若删除成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在；


![image](https://github.com/korangar-group42num1/group42/assets/129478905/16444f82-7de8-4e83-9cb0-e6bcb3271faa)

### Update

更新操作就是**Insert**与**Delete**的结合。
当用户调用Update函数时，

**若value不为空**，则隐式地转为调用Insert；

**若value为空**，则隐式地转为调用Delete，故在此不再赘述。

### Commit

Commit函数提供将内存中的MPT数据持久化到数据库的功能。
在第一章中我们提到的MPT具有快速计算所维护数据集哈希标识以快速状态回滚的能力，也都是在该函数中实现的。

在commit完成后，所有变脏的树节点会重新进行哈希计算，并且将新内容写入数据库；最终新的根节点哈希将被作为MPT的最新状态被返回。

一次MPT树提交是一个递归调用的过程，在介绍MPT提交过程之前，我们首先介绍单个节点是如何进行哈希计算和存储的。

#### 单节点

1.首先是对该节点进行脏位的判断，若当前节点未被修改，则直接返回该节点的哈希值，调用结束
（此外，若当前节点既未被修改，同时存在于内存的时间又”过长“，则将以该节点为根节点的子树从内存中驱除）；

2.该节点为脏节点，对该节点进行哈希重计算。首先是对当前节点的孩子节点进行哈希计算，
对孩子节点的哈希计算是利用递归地对节点进行处理完成。这一步骤的目的是将孩子节点的信息各自转换成一个哈希值进行表示；

3.对当前节点进行哈希计算。哈希计算利用sha256哈希算法对当前节点的RLP编码进行哈希计算；

(1)对于分支节点来说，该节点的RLP编码就是对其孩子列表的内容进行编码，且在第二步中，所有的孩子节点所有已经被转换成了一个哈希值；

(2)对于叶子／扩展节点来说，该节点的RLP编码就是对其Key，Value字段进行编码。同样在第二步中，若Value指代的是另外一个节点的引用，
则已经被转换成了一个哈希值（在第二步中，Key已经被转换成了HP编码）；

4.将当前节点的数据存入数据库，存储的格式为 **[节点哈希值，节点的RLP编码]**

5.将自身的dirty标志置为false，并将计算所得的哈希值进行缓存；

#### MPT树的提交过程

MPT树的提交过程就是以根节点为入口，对根节点进行提交调用即可。

左下角的叶子节点计算得到哈希为0xaa，将其存入数据库中，并在其父节点中用哈希值进行替换；粉色的扩展节点计算得到哈希为0xcc，
在父节点用中0xcc进行替换；递归至根节点，计算得到根节点的哈希为0xee，即整棵树的哈希为0xee。

![image](https://github.com/korangar-group42num1/group42/assets/129478905/dbbc1d3b-67ff-4415-9bd9-be102e34605d)

##### 节点过老的判断依据

```
判断一个节点在内存中存在时间是否过长的依据是：

1.该节点未被修改；

2.当前MPT的计数器减去节点的诞生标志超过了固定的上限；

3.每当MPT调用一次Commit函数，MPT的计数器发生自增；
```

## 默克尔证明

MPT能够提供的一个重要功能 - **默克尔证明**，使用默克尔证明能够实现**轻节点的扩展**。

### 概念

默克尔证明指一个轻节点向一个全节点发起一次证明请求，询问全节点完整的默克尔树中，是否存在一个指定的节点；
全节点向轻节点返回一个默克尔证明路径，由轻节点进行计算，验证存在性。

### 证明过程

如有棵如下图所示的merkle树，如果某个轻节点想要验证9Dog:64这个树节点是否存在与默克尔树中，
只需要向全节点发送该请求，全节点会返回一个1FXq:18, ec20,
8f74的一个路径（默克尔路径，如图2黄色框所表示的）。得到路径之后，轻节点利用9Dog:64与1FXq:18求哈希，
在与ec20求哈希，最后与8f74求哈希，得到的结果与本地维护的根哈希相比，是否相等。

![image](https://github.com/korangar-group42num1/group42/assets/129478905/237bf151-ef0d-4659-b30e-27f3f7590112)


![image](https://github.com/korangar-group42num1/group42/assets/129478905/536eb98f-15d8-437d-ba2c-955034a8f0d3)

### 默克尔证明安全性

（1）若全节点返回的是一条恶意的路径？试图为一个不存在于区块链中的节点伪造一条合法的merkle路径，使得最终的计算结果与区块头中的默克尔根哈希相同。

由于哈希的计算具有不可预测性，使得一个恶意的“全”节点想要为一条不存在的节点伪造一条“伪路径”使得最终计算的根哈希与轻节点所维护的根哈希相同是不可能的。

（2）为什么不直接向全节点请求该节点是否存在于区块链中？

由于在公链的环境中，无法判断请求的全节点是否为恶意节点，因此直接向某一个或者多个全节点请求得到的结果是无法得到保证的。但是轻节点本地维护的区块头信息，是经过工作量证明验证的，也就是经过共识一定正确的，若利用全节点提供的默克尔路径，与代验证的节点进行哈希计算，若最终结果与本地维护的区块头中根哈希一致，则能够证明该节点一定存在于默克尔树中。


# 参考资料

1.https://blog.csdn.net/shangsongwww/article/details/88836617

2.课程ppt：20230407-eth-public

















